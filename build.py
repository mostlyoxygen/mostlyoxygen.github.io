# mostlyoxygen.github.io build script
# Copyright (C) 2022 Mark Sandford
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.


""" Build the site from the markdown files in the source directory. """

import codecs
import jinja2
import sqlite3

from datetime import datetime
from markdown import markdown
from pathlib import Path


TEMPLATE_ENV = jinja2.Environment(
    loader=jinja2.FileSystemLoader(searchpath="templates")
)

SOURCE_DIR = Path("source")
POSTS_DIR = Path("posts")
TAGS_DIR = Path("tags")
INDEX_DIR = Path("indices")

INDEX_LIST_LENGTH = 10  # Number of posts to list on index pages.
SUMMARY_LENGTH = 160  # Max number of characters in list summaries.


def build():
    clean()
    db = sqlite3.connect(":memory:", detect_types=sqlite3.PARSE_DECLTYPES)
    db.row_factory = sqlite3.Row
    cursor = db.cursor()
    cursor.execute("""
        CREATE TABLE posts (
            filename TEXT, title TEXT, summary TEXT, content TEXT,
            created TIMESTAMP, edited TIMESTAMP, template TEXT
        )
    """)
    cursor.execute("CREATE TABLE tags (filename TEXT, tag TEXT)")
    for filename in SOURCE_DIR.glob("*.md"):
        load_post_file(filename, cursor)
    posts = list(cursor.execute("SELECT * FROM posts ORDER BY created DESC"))
    for i, post in enumerate(posts):
        next_post = posts[i-1] if i > 0 else None
        previous_post = posts[i+1] if i+1 < len(posts) else None
        generate_post_page(post, previous_post, next_post, cursor)
    generate_indices(cursor)
    generate_tags(cursor)


def clean():
    """ Remove old files generated by previous runs of this script. """
    for d in (POSTS_DIR, TAGS_DIR, INDEX_DIR):
        for p in d.glob("*.html"):
            p.unlink()
        

def load_post_file(filename, cursor):
    """ Load the information for a post from the given file into the db.
    
    Parameters
    ----------
    filename: str or file-like
        The name of the file to load information from.
    cursor: sqlite3.Cursor
        Cursor for the in-memory database holding data about posts.
    """
    with codecs.open(filename, "r", encoding="utf-8") as f:
        config_lines, content_lines = f.read().split("+++")
    content = markdown(
        content_lines,
        extensions=["fenced_code", "codehilite", "tables"]
    )
    config = {
        key.strip().lower(): value.strip() for key, value in [
            line.split(":") for line in config_lines.split("\n")
            if line.strip() != ""
        ]
    }
    summary = content_lines.split("\n\n")[0].strip()
    summary = summary[:SUMMARY_LENGTH].replace("\n", " ")
    summary = summary[:summary.rindex(" ")]
    creation_date = datetime.strptime(config["created"], "%Y-%m-%d")
    edit_date = config.get("edited", None)
    if edit_date:
        edit_date = datetime.strptime(edit_date, "%Y-%m-%d")
    query = """
        INSERT INTO posts VALUES (
            :filename, :title, :summary, :content, :created,
            :edited, :template
        )
    """
    cursor.execute(query, {
        "filename": filename.stem, "title": config["title"],
        "summary": summary, "content": content,
        "created": creation_date, "edited": edit_date,
        "template": config["template"]
    })
    for tag in [tag.strip() for tag in config["tags"].split(",")]:
        cursor.execute(
            "INSERT INTO tags VALUES (:filename, :tag)",
            {"filename": filename.stem, "tag": tag}
        )


def generate_post_page(post, previous_post, next_post, cursor):
    """ Create a page with the content of the given post.
    
    Parameters:
    post: sqlite3.Row
        Query result from the in-memory database that represents the
        current post.
    previous_post: sqlite3.Row
        Result representing the previous post, chronologically.
    next_post: sqlite3.Row
        Result representing the next post.
    cursor: sqlite3.Cursor
        Cursor object for the in-memory database.
    """
    template = TEMPLATE_ENV.get_template("{}.html".format(post["template"]))
    output_filename = POSTS_DIR / "{}.html".format(post["filename"])
    tags = [
        row[0] for row in cursor.execute(
            "SELECT tag FROM tags WHERE filename=:filename ORDER BY tag",
            {"filename": post["filename"]}
        )
    ]
    if next_post:
        next_post = (
            "{}.html".format(next_post["filename"]),
            next_post["title"], next_post["summary"]
        )
    if previous_post:
        previous_post = (
            "{}.html".format(previous_post["filename"]),
            previous_post["title"], previous_post["summary"]
        )
    with codecs.open(output_filename, "w", encoding="utf-8") as f:
        f.write(template.render(
            title=post["title"], content=post["content"],
            created=post["created"], edited=post["edited"],
            tags=tags, next_post=next_post, previous_post=previous_post
        ))


def generate_indices(cursor):
    """ Create the index pages that list all articles chronologically.

    Parameters
    ----------
    cursor: sqlite3.Cursor
        Cursor object for the in-memory database.
    """
    results = cursor.execute("SELECT * FROM posts ORDER BY created DESC")
    posts = [dict(post) for post in results]
    for post in posts:
        post["tags"] = [
            row[0] for row in cursor.execute(
                "SELECT tag FROM tags WHERE filename=:filename ORDER BY tag",
                {"filename": post["filename"]}
            )
        ]
    posts = [
        posts[i:i+INDEX_LIST_LENGTH]
        for i in range(0, len(posts), INDEX_LIST_LENGTH)
    ]
    total_pages = len(posts)
    template = TEMPLATE_ENV.get_template("index.html")
    for current_page, post_group in enumerate(posts):
        if current_page == 0:
            output = "index.html"
        else:
            output = INDEX_DIR / "index{:03d}.html".format(current_page)
        with codecs.open(output, "w", encoding="utf-8") as f:
            f.write(template.render(
                posts=post_group, current_page=current_page,
                total_pages=total_pages
            ))


def generate_tags(cursor):
    """ Create the page listing tags and pages for each tag listing posts.
    
    Parameters
    ----------
    cursor: sqlite3.Cursor
        Cursor object for the in-memory database.
    """
    tags = [
        [
            t["tag"], t["post_count"], t["filename"], t["title"]
        ]
        for t in cursor.execute("""
            SELECT tag, COUNT(filename) AS post_count, filename, title
            FROM (
                SELECT *
                FROM posts AS p LEFT JOIN tags AS t ON p.filename=t.filename
                ORDER BY p.created DESC
            )
            GROUP BY tag ORDER BY tag
        """)
    ]
    template = TEMPLATE_ENV.get_template("tag-index.html")
    with codecs.open(TAGS_DIR / "index.html", "w", encoding="utf-8") as f:
        f.write(template.render(tags=tags))
    for tag in [t[0] for t in tags]:
        results = cursor.execute("""
            SELECT * FROM posts AS p LEFT JOIN tags AS t
            ON p.filename=t.filename
            WHERE t.tag=:tag ORDER BY p.created DESC
        """, {"tag": tag})
        posts = [dict(r) for r in results]
        posts = [
            posts[i:i+INDEX_LIST_LENGTH]
            for i in range(0, len(posts), INDEX_LIST_LENGTH)
        ]
        total_pages = len(posts)
        template = TEMPLATE_ENV.get_template("tag.html")
        for current_page, post_group in enumerate(posts):
            if current_page == 0:
                output = TAGS_DIR / "{}.html".format(tag)
            else:
                output = TAGS_DIR / "{}{:03d}.html".format(tag, current_page)
            with codecs.open(output, "w", encoding="utf-8") as f:
                f.write(template.render(
                    tag=tag, posts=post_group, current_page=current_page,
                    total_pages=total_pages
                ))


if __name__ == "__main__":
    build()